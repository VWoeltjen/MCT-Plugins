/*******************************************************************************
 * Mission Control Technologies, Copyright (c) 2009-2012, United States Government
 * as represented by the Administrator of the National Aeronautics and Space 
 * Administration. All rights reserved.
 *
 * The MCT platform is licensed under the Apache License, Version 2.0 (the 
 * "License"); you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * http://www.apache.org/licenses/LICENSE-2.0.
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations under 
 * the License.
 *
 * MCT includes source code licensed under additional open source licenses. See 
 * the MCT Open Source Licenses file included with this distribution or the About 
 * MCT Licenses dialog available at runtime from the MCT Help menu for additional 
 * information. 
 *******************************************************************************/
package gov.nasa.arc.mct.generator;

import gov.nasa.arc.mct.api.feed.BufferFullException;
import gov.nasa.arc.mct.api.feed.FeedDataArchive;
import gov.nasa.arc.mct.components.FeedProvider;
import gov.nasa.arc.mct.components.FeedProvider.RenderingInfo;
import gov.nasa.arc.mct.event.services.EventProvider;
import gov.nasa.arc.mct.generator.util.ExpressionEvaluator;
import gov.nasa.arc.mct.services.activity.TimeService;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Queue;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Generates data related to Generator components, based on a 
 * current set of subscriptions. Data is pushed into the feed 
 * data archive, from which the platform will subsequently 
 * retrieve it in order to populate associated feed-driven 
 * views (plots, tables, etc.)
 * 
 * Provides an implementation of EventProvider, which will be 
 * recognized by the platform as a recipient for 
 * subscribe/unsubscribe events by way of OSGi's Declarative 
 * Services.
 * 
 * Depends upon obtaining a reference to a feed data archive, 
 * which is also bound by way of Declarative Services.
 * 
 * See OSGI-INF/services.xml for related declarations.
 * 
 * @author vwoeltje
 *
 */
public class GeneratorEventProvider implements EventProvider {
	/**
	 * Prefix used to identify feeds that should be generated by this EventProvider.
	 */
	public static final String GENERATOR_FEED_PREFIX = "generator:";
	
	
	/**
	 * MCT attaches an additional prefix before subscribe/unsubscribe calls; 
	 * the complete prefix is described here.
	 */
	private static final String COMPLETE_PREFIX = EventProvider.TELEMETRY_TOPIC_PREFIX + GENERATOR_FEED_PREFIX;
	
	/**
	 * The feed data archive, into which data will be pushed.
	 */
	private AtomicReference<FeedDataArchive> archive = new AtomicReference<FeedDataArchive>();
	
	/**
	 * A timer used to generate data for subscribed feeds at scheduled intervals.
	 */
	private Timer timer;
	
	/**
	 * The task performed at scheduled intervals; generates data.
	 */
	private final EvaluatorTask task = new EvaluatorTask();
	
	/**
	 * Most recent timestamp for which data has been generated. Used 
	 * to drive the related TimeService, which MCT will in turn poll 
	 * to determine the "current time" from the perspsective of 
	 * associated feeds.
	 */
	private static long latestTimestamp;
	
	
	@Override
	public Collection<String> subscribeTopics(String... topic) {
		// Filter out any unrelated topics.
		Collection<String> accepted = filter(topic);
		
		//  Start generating data for these.
		task.add(accepted);
		
		// Return the set of topics subscribed to, so MCT can 
		// omit these from subscription requests to other EventProviders.
		return accepted;
	}

	@Override
	public void unsubscribeTopics(String... topic) {
		// Stop generating data for relevant topics.
		task.remove(filter(topic));
	}

	@Override
	public void refresh() {
		// No action needed.
	}
	
	/**
	 * Binds a feed data archive, into which generated data shall 
	 * be pushed. A reference to this object will be obtained by 
	 * way of OSGi's Declarative Services.
	 * 
	 * @param archive the archive into which generated data should go
	 */
	public void bind(FeedDataArchive archive) {
		// Store reference to the archive
		this.archive.set(archive);
		
		// Start running data generation tasks on a timer at one second
		// (1000 ms) intervals, clearing out previous timer if necessary.
		clearTimer();
		timer = new Timer("Data generator");
		timer.scheduleAtFixedRate(task, 1000, 1000);
	}
	
	/**
	 * Unbinds a feed data archive. This will be invoked by OSGi's 
	 * Declarative Services if the feed data archive ever becomes 
	 * unavailable.
	 * 
	 * @param archive the archive into which generated data should no longer go
	 */
	public void unbind(FeedDataArchive archive) {
		// Clear reeference to the archive; it is no longer valid
		this.archive.set(null);
		
		// Stop running data generation tasks; there is no longer 
		// an archive for this data to go into.
		clearTimer();
	}
	
	/**
	 * Stop and dereference the timer used to run data generation 
	 * tasks at one-second intervals.
	 */
	private void clearTimer() {
		if (timer != null) {
			timer.cancel();
			timer = null;
		} 
	}
	
	/**
	 * From a group of subscription ids, retrieve the subset for 
	 * which this data generator is applicable. This is determined 
	 * by the identifier's prefix. 
	 * @param subscriptions array of all subscription ids
	 * @return a collection containing on relevant subscription ids
	 */
	private Collection<String> filter(String[] subscriptions) {
		List<String> filtered = new ArrayList<String>();
		for (String subscription : subscriptions) {
			if (subscription.startsWith(COMPLETE_PREFIX)) {
				filtered.add(subscription);
			}
		}
		return filtered;
	}
	
	/**
	 * Time service associated with generated data. Reports the most 
	 * recent time stamp for which generated data exists.
	 */
	public static final TimeService TIME_SERVICE = new TimeService() {
		@Override
		public long getCurrentTime() {
			return latestTimestamp;
		}		
	};

	/**
	 * Responsible for performing data generation for subscribed 
	 * feeds, and for pushing this data into the archive, where MCT 
	 * will subsequently use it to populate feed-driven views 
	 * (plots, tables, etc.)
	 */
	private class EvaluatorTask extends TimerTask {
		/**
		 * Thread-safe queue of subscription ids which should be 
		 * added to the data generation task.
		 */
		private Queue<String> toAdd = new ConcurrentLinkedQueue<String>();
		
		/**
		 * Thread-safe queue of subscription ids which should be 
		 * removed from the data generation task.
		 */		
		private Queue<String> toRemove = new ConcurrentLinkedQueue<String>();

		/**
		 * Map containing expression evaluators used to generate data 
		 * associated with subscription ids, which are keys.
		 */
		private Map<String, ExpressionEvaluator> evaluators = 
				new HashMap<String, ExpressionEvaluator>();
		
		@Override
		public void run() {
			// Update list of expressions
			while (!toAdd.isEmpty()) {
				performAdd(toAdd.poll());
			}
			while (!toRemove.isEmpty()) {
				performRemove(toRemove.poll());
			}
			
			// Stop working if there are no more subscribed feeds
			if (evaluators.isEmpty()) {
				return;
			}
			
			// Generate data points
			FeedDataArchive archive = GeneratorEventProvider.this.archive.get();
			if (archive != null) {
				// Get the current time, for use on all data points generated this cycle.
				long timestamp = System.currentTimeMillis();
				for (Entry<String, ExpressionEvaluator> entry : evaluators.entrySet()) {
					// Generate the data point
					double value = entry.getValue().evaluate();
					if (!Double.isNaN(value)) {
						try {
							// And push it into the archive.
							archive.putData(entry.getKey().substring(
									EventProvider.TELEMETRY_TOPIC_PREFIX.length()), 
									TimeUnit.MILLISECONDS, 
									timestamp, 
									makeDatum(timestamp, value));
						} catch (BufferFullException e) {
							// TODO Log?
						}
					}
				}
				// Update timestamp exposed by related time service to indicate 
				// "current time", from data feeds perspective.
				latestTimestamp = timestamp;
			}
		}
		
		/**
		 * Create a data point in an MCT-recognized data structure, from 
		 * a trivial time/value pair.
		 * @param time timestamp, in ms since UNIX epoch
		 * @param value numeric value of the data point
		 * @return a map containing MCT-recognized key-value pairs for this datum
		 */
		private Map<String, String> makeDatum(long time, double value) {
			RenderingInfo ri = new RenderingInfo(Double.toString(value), Color.GREEN, " ", Color.GREEN, true);
			ri.setPlottable(true);
			
			Map<String, String> datum = new HashMap<String, String>();
			
			datum.put(FeedProvider.NORMALIZED_IS_VALID_KEY, Boolean.toString(true));
			datum.put(FeedProvider.NORMALIZED_RENDERING_INFO, ri.toString());			
			datum.put(FeedProvider.NORMALIZED_TIME_KEY, Long.toString(time));
			datum.put(FeedProvider.NORMALIZED_VALUE_KEY, Double.toString(value));
			datum.put(FeedProvider.NORMALIZED_TELEMETRY_STATUS_CLASS_KEY, "1");

			return datum;
		}
		
		/**
		 * Add this subscription id to the group of feeds for which data 
		 * is generated. This must only be called from thread which runs 
		 * this task.
		 * @param feedId the subscription id to add
		 */
		private void performAdd(String feedId) {
			if (feedId.startsWith(COMPLETE_PREFIX)) {
				String expr = feedId.substring(COMPLETE_PREFIX.length());
				try {
					evaluators.put(feedId, new ExpressionEvaluator(expr));	
				} catch (IllegalArgumentException iae) {
					// TODO log
				}				
			}
		}
		
		/**
		 * Remove this subscription id from the group of feeds for which data 
		 * is generated. This must only be called from thread which runs 
		 * this task.
		 * @param feedId the subscription id to remove
		 */
		private void performRemove(String feedId) {
			evaluators.remove(feedId);
		}
		
		/**
		 * Start generating data for this group of subscription ids.
		 * 
		 * This method is thread-safe; subscription changes should be 
		 * recognized on the next data generation interval.
		 * 
		 * @param feedIds subscription ids for which data should be generated
		 */
		public void add(Collection<String> feedIds) {
			toAdd.addAll(feedIds);
		}
		
		/**
		 * Stop generating data for this group of subscription ids.
		 * 
		 * This method is thread-safe; subscription changes should be 
		 * recognized on the next data generation interval.
		 * 
		 * @param feedIds subscription ids for which data should no longer be generated
		 */		
		public void remove(Collection<String> feedIds) {
			toRemove.addAll(feedIds);
		}
		
	}
	
}
